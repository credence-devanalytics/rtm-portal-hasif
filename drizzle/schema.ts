import { pgTable, varchar, text, timestamp, doublePrecision, bigint, date, serial, integer, time, interval } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const mentionsClassify = pgTable("mentions_classify", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: 'string' }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	channel: text(),
	channelgroup: text(),
	groupid: varchar(),
	groupname: text(),
	channels: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	topic: varchar(),
	confidence: doublePrecision(),
	sentiment: varchar(),
	inputTokens: doublePrecision("input_tokens"),
	outputTokens: doublePrecision("output_tokens"),
	totalTokens: doublePrecision("total_tokens"),
	downloaddate: date().default(sql`(CURRENT_DATE + '1 day'::interval)`).notNull(),
	idpk: serial().primaryKey().notNull(),
});

export const socialMediaData = pgTable("social_media_data", {
	readableTime: timestamp("readable_time", { withTimezone: true, mode: 'string' }),
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	inserttime: bigint({ mode: "number" }),
	title: text(),
	url: text(),
	image: text(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	sourcereach: doublePrecision(),
	interaction: doublePrecision(),
	influencescore: doublePrecision(),
	followerscount: integer(),
	score: integer(),
	facebookpageid: varchar(),
	likecount: integer(),
	lovecount: integer(),
	wowcount: integer(),
	hahacount: integer(),
	sadcount: integer(),
	angrycount: integer(),
	totalreactionscount: integer(),
	commentcount: integer(),
	sharecount: integer(),
	mediatype: text(),
	fullmention: text(),
	tagfeedlocations: text(),
	engagementrate: doublePrecision(),
	keywordid: varchar(),
	keywordname: text(),
	groupid: varchar(),
	groupname: text(),
	keywordnames: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: integer(),
	retweetcount: integer(),
	replycount: integer(),
	quotecount: integer(),
	twitterhandle: text(),
	tweettype: text(),
	virality: doublePrecision(),
	domain: text(),
	description: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	viewcount: integer(),
	youtubechannelid: varchar(),
	duration: doublePrecision(),
	tiktokid: varchar(),
	diggcount: integer(),
	playcount: integer(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: integer(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	tweetsourcename: text(),
	tweetsourceurl: text(),
	category: text(),
	subCategory: text("sub_category"),
	sentiment: text(),
	inputTokens: varchar("input_tokens"),
	outputTokens: varchar("output_tokens"),
});

export const mentions = pgTable("mentions", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: 'string' }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	keywordname: text(),
	groupid: varchar(),
	groupname: text(),
	keywordnames: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	downloaddate: date().default(sql`(CURRENT_DATE + '1 day'::interval)`).notNull(),
});

export const mentionsClassifyPublic = pgTable("mentions_classify_public", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: 'string' }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	channel: text(),
	channelgroup: text(),
	groupid: varchar(),
	groupname: text(),
	channels: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	topic: varchar(),
	confidence: doublePrecision(),
	sentiment: varchar(),
	inputTokens: doublePrecision("input_tokens"),
	outputTokens: doublePrecision("output_tokens"),
	totalTokens: doublePrecision("total_tokens"),
	downloaddate: date().default(sql`CURRENT_DATE`).notNull(),
	idpk: serial().primaryKey().notNull(),
});

export const unifiViewership = pgTable("unifi_viewership", {
	id: serial().primaryKey().notNull(),
	viewershipMonthYear: text("viewership_month_year"),
	channelName: text("channel_name"),
	programName: text("program_name"),
	programTime: text("program_time"),
	programmeDate: date("programme_date"),
	startTime: time("start_time"),
	endTime: time("end_time"),
	mau: integer(),
	avgAccessDuration: interval("avg_access_duration"),
	sheetName: text("sheet_name"),
	filename: text(),
	duration: interval(),
});

export const mytvAnalysis = pgTable("mytv_analysis", {
	pk: serial().primaryKey().notNull(),
	channel: varchar(),
	metric: varchar(),
	value: doublePrecision(),
	region: varchar(),
	year: integer(),
	page_num: integer(),
	table_idx: integer(),
});

export const mytvViewership = pgTable("mytv_viewership", {
	id: serial().primaryKey().notNull(),
	region: varchar({ length: 100 }),
	metric: varchar({ length: 100 }),
	channel: varchar({ length: 50 }),
	month: varchar({ length: 20 }),
	year: integer(),
	viewers: bigint({ mode: "number" }),
	page_num: integer(),
	table_idx: integer(),
	page_title: text(),
	inserted_at: timestamp({ mode: 'string' }).defaultNow(),
	updated_at: timestamp({ mode: 'string' }).defaultNow(),
});

export const marketingChannelByYear = pgTable("marketing_channel_byyear", {
	id: serial().primaryKey().notNull(),
	report_type: varchar("report_type"),
	report_title: text("report_title"),
	saluran: varchar(),
	groupby: varchar(),
	year: integer(),
	value: varchar(),
	insertdate: timestamp({ mode: 'string' }),
	updatedate: timestamp({ mode: 'string' }),
});

export const marketingChannelByMonth = pgTable("marketing_channel_bymonth", {
	id: serial().primaryKey().notNull(),
	report_type: varchar("report_type"),
	report_title: text("report_title"),
	saluran: varchar(),
	groupby: varchar(),
	year: integer(),
	month: varchar(),
	value: varchar(),
	insertdate: timestamp({ mode: 'string' }),
	updatedate: timestamp({ mode: 'string' }),
});

// Portal Berita Tables
export const pbAudience = pgTable("pb_audience", {
	id: serial().primaryKey().notNull(),
	audienceName: varchar("audienceName", { length: 255 }),
	date: date(),
	totalUsers: integer("totalUsers"),
	newUsers: integer("newUsers"),
});

export const pbAudienceAge = pgTable("pb_audience_age", {
	id: serial().primaryKey().notNull(),
	userAgeBracket: varchar("userAgeBracket", { length: 50 }),
	date: date(),
	activeUsers: integer("activeUsers"),
	newUsers: integer("newUsers"),
});

export const pbAudienceGender = pgTable("pb_audience_gender", {
	id: serial().primaryKey().notNull(),
	userGender: varchar("userGender", { length: 20 }),
	date: date(),
	activeUsers: integer("activeUsers"),
	newUsers: integer("newUsers"),
});

export const pbAudienceRegion = pgTable("pb_audience_region", {
	id: serial().primaryKey().notNull(),
	region: varchar("region", { length: 255 }),
	date: date(),
	activeUsers: integer("activeUsers"),
	newUsers: integer("newUsers"),
});

export const pbAudienceRegionGender = pgTable("pb_audience_region_gender", {
	id: serial().primaryKey().notNull(),
	region: varchar("region", { length: 255 }),
	userGender: varchar("userGender", { length: 20 }),
	date: date(),
	activeUsers: integer("activeUsers"),
	newUsers: integer("newUsers"),
});

export const pbFirstUser = pgTable("pb_first_user", {
	id: serial().primaryKey().notNull(),
	firstUserPrimaryChannelGroup: varchar("firstUserPrimaryChannelGroup", { length: 255 }),
	date: date(),
	totalUsers: integer("totalUsers"),
	newUsers: integer("newUsers"),
	returningUsers: integer("returningUsers"),
});

export const pbFirstUserSource = pgTable("pb_first_user_source", {
	id: serial().primaryKey().notNull(),
	mainSource: varchar("main_source", { length: 255 }),
	date: date(),
	activeUsers: integer("activeUsers"),
});

export const pbPopularPages = pgTable("pb_popular_pages", {
	id: serial().primaryKey().notNull(),
	unifiedScreenClass: text("unifiedScreenClass"),
	date: date(),
	screenPageViews: integer("screenPageViews"),
	activeUsers: integer("activeUsers"),
});

export const pberitaAudienceGender = pgTable("pberita_audience_gender", {
	id: serial().primaryKey().notNull(),
	userGender: varchar("usergender", { length: 20 }),
	date: date(),
	hour: text(),
	activeUsers: integer("activeusers"),
	newUsers: integer("newusers"),
});
