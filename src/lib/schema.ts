import {
	pgTable,
	varchar,
	text,
	timestamp,
	doublePrecision,
	bigint,
	date,
	serial,
	integer,
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";

export const mentionsClassify = pgTable("mentions_classify", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: "string" }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	channel: text(),
	channelgroup: text(),
	groupid: varchar(),
	groupname: text(),
	channels: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	topic: varchar(),
	confidence: doublePrecision(),
	sentiment: varchar(),
	inputTokens: doublePrecision("input_tokens"),
	outputTokens: doublePrecision("output_tokens"),
	totalTokens: doublePrecision("total_tokens"),
	downloaddate: date()
		.default(sql`(CURRENT_DATE + '1 day'::interval)`)
		.notNull(),
	idpk: serial().primaryKey().notNull(),
});

export const socialMediaData = pgTable("social_media_data", {
	readableTime: timestamp("readable_time", {
		withTimezone: true,
		mode: "string",
	}),
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	inserttime: bigint({ mode: "number" }),
	title: text(),
	url: text(),
	image: text(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	sourcereach: doublePrecision(),
	interaction: doublePrecision(),
	influencescore: doublePrecision(),
	followerscount: integer(),
	score: integer(),
	facebookpageid: varchar(),
	likecount: integer(),
	lovecount: integer(),
	wowcount: integer(),
	hahacount: integer(),
	sadcount: integer(),
	angrycount: integer(),
	totalreactionscount: integer(),
	commentcount: integer(),
	sharecount: integer(),
	mediatype: text(),
	fullmention: text(),
	tagfeedlocations: text(),
	engagementrate: doublePrecision(),
	keywordid: varchar(),
	keywordname: text(),
	groupid: varchar(),
	groupname: text(),
	keywordnames: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: integer(),
	retweetcount: integer(),
	replycount: integer(),
	quotecount: integer(),
	twitterhandle: text(),
	tweettype: text(),
	virality: doublePrecision(),
	domain: text(),
	description: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	viewcount: integer(),
	youtubechannelid: varchar(),
	duration: doublePrecision(),
	tiktokid: varchar(),
	diggcount: integer(),
	playcount: integer(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: integer(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	tweetsourcename: text(),
	tweetsourceurl: text(),
	category: text(),
	subCategory: text("sub_category"),
	sentiment: text(),
	inputTokens: varchar("input_tokens"),
	outputTokens: varchar("output_tokens"),
});

export const mentions = pgTable("mentions", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: "string" }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	keywordname: text(),
	groupid: varchar(),
	groupname: text(),
	keywordnames: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	downloaddate: date()
		.default(sql`(CURRENT_DATE + '1 day'::interval)`)
		.notNull(),
});

export const mentionsClassifyPublic = pgTable("mentions_classify_public", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: "string" }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	channel: text(),
	channelgroup: text(),
	groupid: varchar(),
	groupname: text(),
	channels: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	topic: varchar(),
	confidence: doublePrecision(),
	sentiment: varchar(),
	inputTokens: doublePrecision("input_tokens"),
	outputTokens: doublePrecision("output_tokens"),
	totalTokens: doublePrecision("total_tokens"),
	downloaddate: date()
		.default(sql`CURRENT_DATE`)
		.notNull(),
	idpk: serial().primaryKey().notNull(),
});

export const marketingChannelByYear = pgTable("marketing_channel_byyear", {
	id: serial().primaryKey().notNull(),
	report_type: varchar("report_type"),
	report_title: text("report_title"),
	saluran: varchar(),
	groupby: varchar(),
	year: integer(),
	value: varchar(),
	insertdate: timestamp({ mode: "string" }),
	updatedate: timestamp({ mode: "string" }),
});

export const marketingChannelByMonth = pgTable("marketing_channel_bymonth", {
	id: serial().primaryKey().notNull(),
	report_type: varchar("report_type"),
	report_title: text("report_title"),
	saluran: varchar(),
	groupby: varchar(),
	year: integer(),
	month: varchar(),
	value: varchar(),
	insertdate: timestamp({ mode: "string" }),
	updatedate: timestamp({ mode: "string" }),
});
