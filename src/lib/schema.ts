import {
	pgTable,
	varchar,
	text,
	timestamp,
	doublePrecision,
	bigint,
	date,
	serial,
	integer,
	unique,
	boolean,
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";

export const mentionsClassify = pgTable("mentions_classify", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: "string" }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	channel: text(),
	channelgroup: text(),
	groupid: varchar(),
	groupname: text(),
	channels: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	topic: varchar(),
	confidence: doublePrecision(),
	sentiment: varchar(),
	inputTokens: doublePrecision("input_tokens"),
	outputTokens: doublePrecision("output_tokens"),
	totalTokens: doublePrecision("total_tokens"),
	downloaddate: date()
		.default(sql`(CURRENT_DATE + '1 day'::interval)`)
		.notNull(),
	idpk: serial().primaryKey().notNull(),
});

export const socialMediaData = pgTable("social_media_data", {
	readableTime: timestamp("readable_time", {
		withTimezone: true,
		mode: "string",
	}),
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	inserttime: bigint({ mode: "number" }),
	title: text(),
	url: text(),
	image: text(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	sourcereach: doublePrecision(),
	interaction: doublePrecision(),
	influencescore: doublePrecision(),
	followerscount: integer(),
	score: integer(),
	facebookpageid: varchar(),
	likecount: integer(),
	lovecount: integer(),
	wowcount: integer(),
	hahacount: integer(),
	sadcount: integer(),
	angrycount: integer(),
	totalreactionscount: integer(),
	commentcount: integer(),
	sharecount: integer(),
	mediatype: text(),
	fullmention: text(),
	tagfeedlocations: text(),
	engagementrate: doublePrecision(),
	keywordid: varchar(),
	keywordname: text(),
	groupid: varchar(),
	groupname: text(),
	keywordnames: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: integer(),
	retweetcount: integer(),
	replycount: integer(),
	quotecount: integer(),
	twitterhandle: text(),
	tweettype: text(),
	virality: doublePrecision(),
	domain: text(),
	description: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	viewcount: integer(),
	youtubechannelid: varchar(),
	duration: doublePrecision(),
	tiktokid: varchar(),
	diggcount: integer(),
	playcount: integer(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: integer(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	tweetsourcename: text(),
	tweetsourceurl: text(),
	category: text(),
	subCategory: text("sub_category"),
	sentiment: text(),
	inputTokens: varchar("input_tokens"),
	outputTokens: varchar("output_tokens"),
});

export const mentions = pgTable("mentions", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: "string" }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	keywordname: text(),
	groupid: varchar(),
	groupname: text(),
	keywordnames: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	downloaddate: date()
		.default(sql`(CURRENT_DATE + '1 day'::interval)`)
		.notNull(),
});

export const mentionsClassifyPublic = pgTable("mentions_classify_public", {
	id: varchar(),
	type: text(),
	mention: text(),
	languages: text(),
	from: text(),
	author: text(),
	inserttime: timestamp({ mode: "string" }),
	title: text(),
	url: text(),
	image: text(),
	reach: doublePrecision(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	databaseinserttime: bigint({ mode: "number" }),
	keywords: text(),
	locations: text(),
	autosentiment: text(),
	interaction: doublePrecision(),
	score: doublePrecision(),
	youtubechannelid: varchar(),
	viewcount: doublePrecision(),
	likecount: doublePrecision(),
	commentcount: doublePrecision(),
	fullmention: text(),
	description: text(),
	duration: doublePrecision(),
	tagfeedlocations: text(),
	keywordid: varchar(),
	channel: text(),
	channelgroup: text(),
	groupid: varchar(),
	groupname: text(),
	channels: text(),
	sourcereach: doublePrecision(),
	influencescore: doublePrecision(),
	photo: text(),
	originalphoto: text(),
	photos: text(),
	originalphotos: text(),
	virality: doublePrecision(),
	domain: text(),
	sharecount: doublePrecision(),
	engagementrate: doublePrecision(),
	followerscount: doublePrecision(),
	facebookpageid: varchar(),
	lovecount: doublePrecision(),
	wowcount: doublePrecision(),
	hahacount: doublePrecision(),
	sadcount: doublePrecision(),
	angrycount: doublePrecision(),
	totalreactionscount: doublePrecision(),
	mediatype: text(),
	authorgender: text(),
	twitterprofileid: varchar(),
	favoritecount: doublePrecision(),
	retweetcount: doublePrecision(),
	replycount: doublePrecision(),
	quotecount: doublePrecision(),
	twitterhandle: text(),
	tweettype: text(),
	instagramprofileid: varchar(),
	instagramprofilename: text(),
	instagrampostid: varchar(),
	posttype: text(),
	tiktokid: varchar(),
	diggcount: doublePrecision(),
	playcount: doublePrecision(),
	videodurationseconds: doublePrecision(),
	authorfollowercount: doublePrecision(),
	subreddit: text(),
	reddittype: text(),
	redditfullname: text(),
	redditscore: doublePrecision(),
	redditcommentid: varchar(),
	redditparentlinkid: varchar(),
	insertdate: date(),
	topic: varchar(),
	confidence: doublePrecision(),
	sentiment: varchar(),
	inputTokens: doublePrecision("input_tokens"),
	outputTokens: doublePrecision("output_tokens"),
	totalTokens: doublePrecision("total_tokens"),
	downloaddate: date()
		.default(sql`CURRENT_DATE`)
		.notNull(),
	idpk: serial().primaryKey().notNull(),
});

export const marketingChannelByYear = pgTable("marketing_channel_byyear", {
	id: serial().primaryKey().notNull(),
	report_type: varchar("report_type"),
	report_title: text("report_title"),
	saluran: varchar(),
	groupby: varchar(),
	year: integer(),
	value: varchar(),
	insertdate: timestamp({ mode: "string" }),
	updatedate: timestamp({ mode: "string" }),
});

export const marketingChannelByMonth = pgTable("marketing_channel_bymonth", {
	id: serial().primaryKey().notNull(),
	report_type: varchar("report_type"),
	report_title: text("report_title"),
	saluran: varchar(),
	groupby: varchar(),
	year: integer(),
	month: varchar(),
	value: varchar(),
	insertdate: timestamp({ mode: "string" }),
	updatedate: timestamp({ mode: "string" }),
});

export const pberitaAudienceGender = pgTable(
	"pberita_audience_gender",
	{
		id: serial().primaryKey().notNull(),
		usergender: text(),
		date: date(),
		hour: text(),
		activeusers: integer(),
		newusers: integer(),
	},
	(table) => [
		unique("uq_pberita_audience_gender_usergender_date_hour").on(
			table.usergender,
			table.date,
			table.hour
		),
	]
);

export const pberitaAudienceAge = pgTable(
	"pberita_audience_age",
	{
		id: serial().primaryKey().notNull(),
		useragebracket: text(),
		date: date(),
		hour: text(),
		activeusers: integer(),
		newusers: integer(),
	},
	(table) => [
		unique("uq_pberita_audience_age_useragebracket_date_hour").on(
			table.useragebracket,
			table.date,
			table.hour
		),
	]
);

export const rtmklikGender = pgTable(
	"rtmklik_gender",
	{
		id: serial().primaryKey().notNull(),
		date: date(),
		hour: text(),
		gender: text(),
		metric: text(),
		value: integer(),
	},
	(table) => [
		unique("uq_rtmklik_gender_gender_hour_date_metric").on(
			table.date,
			table.hour,
			table.gender,
			table.metric
		),
	]
);

export const rtmklikAge = pgTable(
	"rtmklik_age",
	{
		id: serial().primaryKey().notNull(),
		date: date(),
		hour: text(),
		age: text(),
		metric: text(),
		value: integer(),
	},
	(table) => [
		unique("uq_rtmklik_age_age_hour_date_metric").on(
			table.date,
			table.hour,
			table.age,
			table.metric
		),
	]
);

// BetterAuth expects these exact table names and structures + medina user excel sheet fields
export const users = pgTable("user", {
	id: text("id").primaryKey(),
	name: text("name").notNull(),
	email: text("email").notNull().unique(),
	role: text("role").notNull().default("user"), 	// peranan dalam sistem
	position: text("position"),  					// jawatan 
	systemId: text("systemId"),  					// user ID based on excel sheet
	taskRole: text("taskRole"), 					// peranan tugas
	emailVerified: boolean("emailVerified"),
	image: text("image"),
	createdAt: timestamp("createdAt").notNull(),
	updatedAt: timestamp("updatedAt").notNull(),
});

export const sessions = pgTable("session", {
	id: text("id").primaryKey(),
	expiresAt: timestamp("expiresAt").notNull(),
	token: text("token").notNull().unique(),
	createdAt: timestamp("createdAt").notNull(),
	updatedAt: timestamp("updatedAt").notNull(),
	ipAddress: text("ipAddress"),
	userAgent: text("userAgent"),
	userId: text("userId")
		.notNull()
		.references(() => users.id),
});

export const accounts = pgTable("account", {
	id: text("id").primaryKey(),
	accountId: text("accountId").notNull(),
	providerId: text("providerId").notNull(),
	userId: text("userId")
		.notNull()
		.references(() => users.id),
	accessToken: text("accessToken"),
	refreshToken: text("refreshToken"),
	idToken: text("idToken"),
	accessTokenExpiresAt: timestamp("accessTokenExpiresAt"),
	refreshTokenExpiresAt: timestamp("refreshTokenExpiresAt"),
	scope: text("scope"),
	password: text("password"),
	createdAt: timestamp("createdAt").notNull(),
	updatedAt: timestamp("updatedAt").notNull(),
});

export const verificationTokens = pgTable("verification", {
	id: text("id").primaryKey(),
	identifier: text("identifier").notNull(),
	value: text("value").notNull(),
	expiresAt: timestamp("expiresAt").notNull(),
	createdAt: timestamp("createdAt"),
	updatedAt: timestamp("updatedAt"),
});